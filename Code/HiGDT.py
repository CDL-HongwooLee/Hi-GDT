import subprocess as sp
import sys
import argparse
import os
import numpy as np
import pickle
from scipy import stats
import time
import multiprocessing as mp
from functools import partial
import itertools

##usage
def parse_args():
    parser = argparse.ArgumentParser(description = "", formatter_class = argparse.RawTextHelpFormatter)
    parser.add_argument('-b', dest = 'bedfile', required=True, help = 
    '''Path to the .bed file which includes genic information.
The 4th column should contain the label of each element.
    ''')
    parser.add_argument('-c', dest = 'chromSize', required=True, help = 
    '''Path to the .chrom.sizes file.
    ''')
    parser.add_argument('-p', dest = 'prefix', required=True, help = 
    '''Prefix for naming output files.
    ''')
    parser.add_argument('-j', dest = 'juicertools', default = False, help = 
    '''Path to the juicer_tools.jar file. Not required if the "--skip" option is used.
    ''')
    parser.add_argument('-hic', dest = 'hic', default = False, help = 
    '''Path to the .hic file. Not required if the "--skip" option is used.
    ''')
    parser.add_argument('-n', dest = 'norm', default = "SCALE", help = 
    '''Normalization method. Choose one of ["NONE", "VC", "VC_SQRT", "KR", "SCALE"]. 
Not required if the "--skip" option is used.
Default = 'SCALE'.
    ''')
    parser.add_argument('--skip', dest = 'skip', action='store_true', help = 
    '''Use this flag to skip generating matrix.pickle file(s) from a .hic file. 
You can use this flag if you've previously generated matrix.pickle file(s) using HiGDT.py.
if set, -i1 {matrix.pickle} [-i2 {matrix2.pickle}] option(s) is required for input file(s).
    ''')
    parser.add_argument('-i1', dest = 'infile1', default = False, help = 
    '''Path to the input matrix.pickle file generated at resolution1 (r1).
By default, this file is generated at {outdir}/{prefix}.{resolution}{BP/FRAG}.matrix.pickle.
    ''')
    parser.add_argument('-i2', dest = 'infile2', default = False, help = 
    '''Path to the input matrix.pickle file generated at resolution2 (r2). 
Required only if r1 != r2.
    ''')

    parser.add_argument('-o', dest = 'outdir', default = './', help = 
    '''Path to the output directory where whole output files will be written.
Default = './'.
    ''')
    parser.add_argument('-bf', dest = 'BP_FRAG', default = "BP", help = 
    '''The unit of resolution; basepair or restriction fragment.
Choose one of ["BP", "FRAG"].
Default = 'BP'.
    ''')
    parser.add_argument('-f', dest = 'resfile', default = False, help = 
    '''Path to the space-delimited whole-genome digestion file.
Required only for restriction fragment resolution analysis.
This file can be generated by Juicer utils.
    ''')
    parser.add_argument('-r1', dest = 'resolution1', default = 250, type = int, help = 
    '''Resolution for single-gene domain analysis.
r1 = 250 (BP) or r1 = 1 (FRAG) is recommended if you have enough sequencing depth.
Default = 250 (BP). 
    ''')
    parser.add_argument('-r2', dest = 'resolution2', default = 500, type = int, help = 
    '''Resolution for multigene domain analysis.
r2 = 500 (BP) or r2 = 2 (FRAG) is recommended if you have enough sequencing depth.
Default = 500 (BP). 
    ''')
    parser.add_argument('-c1', dest = 'cutoff1', default = 0.05, type = float, help = 
    '''P-value cutoff for single-gene domain analysis.
Default = 0.05.
    ''')
    parser.add_argument('-c2', dest = 'cutoff2', default = 0.05, type = float, help = 
    '''P-value cutoff for multi-gene domain analysis.
Default = 0.05.
    ''')
    parser.add_argument('-s', dest = 'maxSize', default = 10, type = int, help = 
    '''The maximum number of genes in a multi-gene domain.
Larger number may slow down the analysis.
Default = 10.
    ''')
    parser.add_argument('-d', dest = 'maxDist', default = 50000, type = int, help = 
    '''The maximum distance (bp) between the first and the last gene in a multi-gene domain. 
Default = 50000.
    ''')
    parser.add_argument('-t', dest = 'threads', default = 1, type = int, help = 
    '''Number of threads to use. Ideally equal to the number of chromosomes.
Default = 1.
    ''')
    return parser.parse_args()

def getVariables(chromsize, resfile1, resfile2, bedfile):
    chromlist = sp.check_output(f'less {chromsize} | cut -f 1', shell=True, universal_newlines=True).rstrip().split('\n')
    chrStartFragNumDic1 = dict() ; chrEndFragNumDic1 = dict() ; chrStartFragNumDic2 = dict() ; chrEndFragNumDic2 = dict()
    chrStartEndFragList1 = sp.check_output(f'less {resfile1} | datamash groupby 1 min 4 max 4', shell=True, universal_newlines=True).strip().split('\n')
    chrStartEndFragList2 = sp.check_output(f'less {resfile2} | datamash groupby 1 min 4 max 4', shell=True, universal_newlines=True).strip().split('\n')
    for line in chrStartEndFragList1:
        chr, start, end = line.rstrip().split('\t')
        chrStartFragNumDic1[chr] = int(start)
        chrEndFragNumDic1[chr] = int(end)
    for line in chrStartEndFragList2:
        chr, start, end = line.rstrip().split('\t')
        chrStartFragNumDic2[chr] = int(start)
        chrEndFragNumDic2[chr] = int(end)

    startDic = dict() ; endDic = dict() ; strandDic = dict()
    with open(bedfile) as b1:
        for line in b1:
            _, start, end, geneid, _, strand = line.rstrip().split('\t')
            startDic[geneid] = start
            endDic[geneid] = end
            strandDic[geneid] = strand

    return chromlist, chrStartFragNumDic1, chrEndFragNumDic1, chrStartFragNumDic2, chrEndFragNumDic2, startDic, endDic, strandDic

def MaketmpDir(outdir):
    if os.path.isdir(f'{outdir}') == False:
        os.mkdir(f'{outdir}')
    if os.path.isdir(f'{outdir}/tmp') == False:
        os.mkdir(f'{outdir}/tmp')

def DumpMatrix(outdir, prefix, juicer_tools, norm, hic, res1, res2, bf, chromlist, t):
    if res1 != res2:
        sp.run(f"parallel -j {t} \"java -jar {juicer_tools} dump oe {norm} {hic} {{1}} {{1}} {bf} {{2}} {outdir}/tmp/{prefix}.{{1}}_{{1}}.{{2}}{bf}.txt\" ::: $(echo {' '.join(chromlist)}) ::: $(echo {res1} {res2})", shell=True)
    else:
        sp.run(f"parallel -j {t} \"java -jar {juicer_tools} dump oe {norm} {hic} {{1}} {{1}} {bf} {{2}} {outdir}/tmp/{prefix}.{{1}}_{{1}}.{{2}}{bf}.txt\" ::: $(echo {' '.join(chromlist)}) ::: $(echo {res1})", shell=True)

def MakeIFpickleFiles(outdir, prefix, chrStartFragNumDic1, chrStartFragNumDic2, chromlist, res1, res2, bf, t):

    pool = mp.Pool(processes=t)
    func_parallel = partial(MakeChrompickle, outdir, prefix, bf)
    if res1 != res2:
        pool.map(func_parallel, itertools.product(chromlist, zip([res1,res2], [chrStartFragNumDic1,chrStartFragNumDic2])))
    else:
        pool.map(func_parallel, itertools.product(chromlist, zip([res1], [chrStartFragNumDic1])))
    pool.close()
    pool.join()
        
    mergedDic1 = dict()
    for chrom in chromlist:
        with open(f'{outdir}/tmp/{prefix}.{chrom}_{chrom}.{res1}{bf}.matrix.pickle', 'rb') as pk:
            mergedDic1[chrom] = pickle.load(pk)
    with open(f'{outdir}/{prefix}.{res1}{bf}.matrix.pickle','wb') as pko:
        pickle.dump(mergedDic1, pko)

    if res1 != res2:
        mergedDic2 = dict()
        for chrom in chromlist:
            with open(f'{outdir}/tmp/{prefix}.{chrom}_{chrom}.{res2}{bf}.matrix.pickle', 'rb') as pk:
                mergedDic2[chrom] = pickle.load(pk)
        with open(f'{outdir}/{prefix}.{res2}{bf}.matrix.pickle','wb') as pko:
            pickle.dump(mergedDic2, pko)

        return mergedDic1, mergedDic2
    return mergedDic1

def MakeChrompickle(outdir, prefix, bf, params):
    chrom, (res, chrStartFragNumDic) = params
    chromIFdic = dict()
    chrStart = chrStartFragNumDic[chrom]
    with open(f'{outdir}/tmp/{prefix}.{chrom}_{chrom}.{res}{bf}.txt') as i1, open(f'{outdir}/tmp/{prefix}.{chrom}_{chrom}.{res}{bf}.matrix.pickle', 'wb') as p1:
        for line in i1:
            bin1, bin2, value = line.rstrip().split('\t')
            if bin1 == bin2:
                value = float(0)
            if value != 'NaN' and value != "nan":
                chromIFdic[f'{int(bin1)/res+chrStart:.0f}' + '\t' + f'{int(bin2)/res+chrStart:.0f}'] = float(value)
        pickle.dump(chromIFdic, p1)

def LoadIFpickleFile(infile):
    with open(infile, 'rb') as pk:
        chromIFdic = pickle.load(pk)
    return chromIFdic

def GetminMaxFragOfGene(bedfile, resfile, res, outdir, prefix, bf, chromlist):
    sp.run(f'bedtools intersect -a {bedfile} -b {resfile} -wo | datamash groupby 1,2,3,4,5,6 min 10 max 10 > {outdir}/tmp/{prefix}.FragmentGene.{res}{bf}.txt', shell=True) 
    Gene_minMaxFragDic = dict()
    for c in chromlist:
        Gene_minMaxFragDic[c] = dict()
    with open(f'{outdir}/tmp/{prefix}.FragmentGene.{res}{bf}.txt') as f1:
        for line in f1:
            chrom, _, _, geneid, _, _, m, M = line.rstrip().split('\t')
            Gene_minMaxFragDic[chrom][geneid] = (int(m),int(M))
    return Gene_minMaxFragDic

def makeFRAGbed(outdir, prefix, resfile, res1, res2):
    for r in [res1, res2]:
        with open(resfile) as r1, open(f'{outdir}/{prefix}.{r}FRAG.bed', 'w') as o1:
            n=1
            for line in r1:
                chr_name = line.split(' ')[0]
                frags = line.rstrip().split(' ')[1:]
                frags.insert(0,'1')
                
                for i in range((len(frags)-1)//r):
                    o1.write(chr_name + '\t' + frags[r*i] + '\t' + frags[r*(i+1)] + '\t' + str(n) + '\n')
                    n+=1
                if (len(frags)-1)%r!=0:
                    o1.write(chr_name + '\t' + frags[r*(i+1)] + '\t' + frags[-1] + '\t' + str(n) + '\n')
                    n+=1
    return f'{outdir}/{prefix}.{res1}FRAG.bed', f'{outdir}/{prefix}.{res2}FRAG.bed'

def makeBPbed(outdir, prefix, res1, res2, chromfile):
    for r in [res1, res2]:
        with open(chromfile) as f1, open(f'{outdir}/{prefix}.{r}BP.bed','w') as o1:
            x=1
            for line in f1:
                chrom, size = line.rstrip().split('\t')
                o1.write('\t'.join([chrom, '1', str(1*r), str(x)]) + '\n')
                for i in range(1,int(size)//r):
                    o1.write('\t'.join([chrom, str(i*r), str((i+1)*r), str(i+x)]) + '\n')
                o1.write('\t'.join([chrom, str((i+1)*r), size, str(i+x+1)]) + '\n')
                x=x+i+1
    return f'{outdir}/{prefix}.{res1}BP.bed', f'{outdir}/{prefix}.{res2}BP.bed'

def IdentifySingleGeneDomain(outdir, prefix, minMaxDic, IFdic, chromlist, window, p_cutoff, t, minN=3):
    pool = mp.Pool(processes=t)
    single_parallel = partial(CompareSingle, outdir, prefix, window, minN, p_cutoff)
    pool.starmap(single_parallel, zip(chromlist, list(IFdic.values()), list(minMaxDic.values())))
    pool.close()
    pool.join()

    chroms = ' '.join(chromlist)
    sp.run(f"parallel -j 1 \"cat {outdir}/tmp/{prefix}.{{1}}.single.tmp\" ::: $(echo {chroms}) > {outdir}/tmp/{prefix}.single.tmp", shell=True)
    sp.run(f"less {outdir}/tmp/{prefix}.single.tmp | awk '$9==\"Single\"' | cut -f -8 > {outdir}/{prefix}.SingleGeneDomain.txt", shell=True)

def CompareSingle(outdir, prefix, window, minN, p_cutoff, chrom, IFdic, minMaxDic):
    gl = list(minMaxDic.keys())
    with open(f'{outdir}/tmp/{prefix}.{chrom}.single.tmp', 'w') as o1:
        for target in gl:
            target_i, target_j = minMaxDic[target]
            w_size = int(window*(target_j - target_i + 1))
            w_shift = int(window*(target_j - target_i + 2))

            up_contact = [] ; target_contact = [] ; down_contact = []
            
            for i in range(target_i, target_j - w_shift + 1):
                for j in range(i + w_shift, target_j + 1):
                    try:
                        target_contact.append(IFdic[str(i) + '\t' + str(j)])
                    except KeyError:
                        target_contact.append(float(0))
                    try:
                        up_contact.append(IFdic[str(i - w_size) + '\t' + str(j - w_size)])
                    except KeyError:
                        up_contact.append(float(0))
                    try:
                        down_contact.append(IFdic[str(i + w_size) + '\t' + str(j + w_size)])
                    except KeyError:
                        down_contact.append(float(0))
                        
            if target_j - target_i >= minN:
                p1 = stats.mannwhitneyu(up_contact, target_contact)[1]
                p2 = stats.mannwhitneyu(down_contact, target_contact)[1]
                if p1 < p_cutoff and p2 < p_cutoff and np.mean(target_contact) > np.mean(up_contact) and np.mean(target_contact) > np.mean(down_contact):
                    domain = "Single"
                else:
                    domain = "None"
            else:
                p1 = 1.0
                p2 = 1.0
                domain = "Short"
            o1.write('\t'.join([chrom, GeneStartDic[target], GeneEndDic[target], target, str(1), GeneStrandDic[target], str(p1), str(p2), domain]) + '\n')

def IdentifyMultiGeneDomain(outdir, prefix, chrEndFragNumDic2, minMaxDic, IFdic, chromlist, maxGeneN, maxDist, p_cutoff, t, minN=3):
    pool = mp.Pool(processes=t)
    single_parallel = partial(CompareMulti, outdir, prefix, minN, maxGeneN, maxDist, p_cutoff, chrEndFragNumDic2)
    pool.starmap(single_parallel, zip(chromlist, list(IFdic.values()), list(minMaxDic.values())))
    pool.close()
    pool.join()

    chroms = ' '.join(chromlist)
    sp.run(f"parallel -j 1 \"cat {outdir}/tmp/{prefix}.{{1}}.multi.tmp\" ::: $(echo {chroms}) > {outdir}/{prefix}.MultiGeneDomain.txt", shell=True)

def CompareMulti(outdir, prefix, minN, maxGeneN, maxDist, p_cutoff, chrEndFragNumDic, chrom, IFdic, minMaxDic):
    gl = list(minMaxDic.keys())
    with open(f'{outdir}/tmp/{prefix}.{chrom}.multi.tmp', 'w') as o1:
        i = 0
        while i < len(gl) - 1:
            m = 1
            while 1:
                if i+m == len(gl) or m >= maxGeneN:
                    break
                p1_1 = CompareForward(minMaxDic, IFdic, gl[i], gl[i+m], minN, maxDist)
                p1_2 = CompareForward_stack(minMaxDic, IFdic, gl[i], gl[i+1], gl[i+m])
                if p1_1 != False and p1_1 < p_cutoff and p1_2 < p_cutoff:
                    p1_3 = CompareForward_oppositeSite(minMaxDic, IFdic, gl[i], gl[i+1], gl[i+m])
                    p2_1 = CompareBackward(minMaxDic, IFdic, gl[i], gl[i+m], chrEndFragNumDic[chrom])
                    p2_2 = CompareBackward_stack(minMaxDic, IFdic, gl[i], gl[i+m-1], gl[i+m])
                    p2_3 = CompareBackward_oppositeSite(minMaxDic, IFdic, gl[i], gl[i+m-1], gl[i+m])
                    if p1_3 < p_cutoff and p2_1 !=False and p2_1 < p_cutoff and p2_2 < p_cutoff and p2_3 < p_cutoff:
                        plist = [str(p1_1),str(p1_2),str(p1_3), str(p2_1), str(p2_2), str(p2_3)]
                        genes = gl[i:i+m+1]                        
                        strands = list(GeneStrandDic[g] for g in genes)                  
                        o1.write(chrom + '\t' + GeneStartDic[gl[i]] + '\t' + GeneEndDic[gl[i+m]] + '\t' + ':'.join(genes) + '\t' + str(m+1) + '\t' + ':'.join(strands) + '\t' + '\t'.join(plist) + '\n')                        
                    m+=1
                else:
                    break
            i+=1

def CompareForward(minMaxDic, IFdic, target, down, minN, maxDist):
    target_i, target_j = minMaxDic[target]
    down_i, down_j = minMaxDic[down]
    if target_i - (down_j - target_j) < 0 or int(GeneStartDic[down])-int(GeneEndDic[target]) > maxDist:
        return False
    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(target_i - (j-target_j)) + '\t' + str(i)])
            except KeyError:
                control_contact.append(float(0))
    if len(target_contact) >= minN:
        p = stats.mannwhitneyu(target_contact, control_contact)[1]
        if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
            p = 1.0
    else:
        p = 1.0
    return p

def CompareForward_stack(minMaxDic, IFdic, target, target_next, down):
    target_i, target_j = minMaxDic[target]
    down_i = minMaxDic[target_next][0]
    down_j = minMaxDic[down][1]
    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(target_i - (j-target_j)) + '\t' + str(i)])
            except KeyError:
                control_contact.append(float(0))
    p = stats.mannwhitneyu(target_contact, control_contact)[1]
    if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
        p = 1.0
    return p

def CompareBackward(minMaxDic, IFdic, target, down, chromEnd):
    target_i, target_j = minMaxDic[target]
    down_i, down_j = minMaxDic[down]
    if down_j + down_i - target_i > chromEnd:
        return 1.0
    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(j) + '\t' + str(down_j + down_i - i)])
            except KeyError:
                control_contact.append(float(0))
    p = stats.mannwhitneyu(target_contact, control_contact)[1]
    if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
        p = 1.0
    return p

def CompareBackward_stack(minMaxDic, IFdic, target, before_down, down):
    target_i = minMaxDic[target][0]
    target_j = minMaxDic[before_down][1]
    down_i, down_j = minMaxDic[down]
    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(j) + '\t' + str(down_j + down_i - i)])
            except KeyError:
                control_contact.append(float(0))
    p = stats.mannwhitneyu(target_contact, control_contact)[1]
    if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
        p = 1.0
    return p

def CompareForward_oppositeSite(minMaxDic, IFdic, target, target_next, down):
    target_i, target_j = minMaxDic[target]
    down_i = minMaxDic[target_next][0]
    down_j = minMaxDic[down][1]
    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(j) + '\t' + str(down_j + down_i - i)])
            except KeyError:
                control_contact.append(float(0))
    p = stats.mannwhitneyu(target_contact, control_contact)[1]
    if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
        p = 1.0
    return p
           
def CompareBackward_oppositeSite(minMaxDic, IFdic, target, before_down, down):
    target_i = minMaxDic[target][0]
    target_j = minMaxDic[before_down][1]
    down_i, down_j = minMaxDic[down]

    target_contact = [] ; control_contact = []
    for i in range(target_i, target_j+1):
        for j in range(down_i, down_j+1):
            try:
                target_contact.append(IFdic[str(i) + '\t' + str(j)])
            except KeyError:
                target_contact.append(float(0))
            try:
                control_contact.append(IFdic[str(target_i - (j - target_j)) + '\t' + str(i)])
            except KeyError:
                control_contact.append(float(0))
    p = stats.mannwhitneyu(target_contact, control_contact)[1]
    if np.mean(target_contact) < np.mean(control_contact) or np.median(target_contact) == 0 or np.median(control_contact) == 0:
        p = 1.0
    return p

def MakeAdditionalFiles(outdir, prefix, t):
    sp.run(f"cat {outdir}/{prefix}.SingleGeneDomain.txt {outdir}/{prefix}.MultiGeneDomain.txt | sort -k1,1 -k2,2n -k3,3n > {outdir}/{prefix}.MergedGeneDomain.txt", shell=True)
    sp.run(f"parallel -j {t} \"less {outdir}/{prefix}.{{1}}GeneDomain.txt | awk '{{print \$1, \$2, \$3, \$1, \$2, \$3}}' OFS='\t' > {outdir}/{prefix}.{{1}}GeneDomain.juicebox.bed\" ::: $(echo Single Multi Merged)", shell=True)

def tmpClearing(outdir, prefix, res1, res2, BP_FRAG):
    sp.run(f"rm {outdir}/tmp/{prefix}.*.tmp {outdir}/tmp/{prefix}.Chr*.txt {outdir}/tmp/{prefix}.*_*.{res1}{BP_FRAG}.matrix.pickle \
    {outdir}/tmp/{prefix}.*_*.{res2}{BP_FRAG}.matrix.pickle {outdir}/tmp/{prefix}.FragmentGene.{res1}{BP_FRAG}.txt \
    {outdir}/tmp/{prefix}.FragmentGene.{res2}{BP_FRAG}.txt", shell=True)
    

if __name__ == '__main__':
    args = parse_args()

    MaketmpDir(args.outdir)
    if args.BP_FRAG == "BP":
        if args.resolution1 < 100 or args.resolution2 < 100:
            print(f'### Too high resolution is defined : {args.BP_FRAG} -- {args.resolution1}, {args.resolution2}')
            sys.exit()
        resfile1, resfile2 = makeBPbed(args.outdir, args.prefix, args.resolution1, args.resolution2, args.chromSize)
    elif args.BP_FRAG == "FRAG":
        if args.resolution1 >= 100 or args.resolution2 >= 100:
            print(f'### Too low resolution is defined : {args.BP_FRAG} -- {args.resolution1}, {args.resolution2}')
        if args.resfile == False:
            print('###Error### Restriction fragment file is required.')
            sys.exit()
        resfile1, resfile2 = makeFRAGbed(args.outdir, args.prefix, args.resfile, args.resolution1, args.resolution2)
    else:
        print(f'###Error### Wrong BP_FRAG name : {args.BP_FRAG}')
        sys.exit()
    
    chromlist, chrStartFragNumDic1, chrEndFragNumDic1, chrStartFragNumDic2, chrEndFragNumDic2, GeneStartDic, GeneEndDic, GeneStrandDic = getVariables(args.chromSize, resfile1, resfile2, args.bedfile)
    print('\n HiGDT -- version 1.0.0')
    start_time = time.time()
    if args.skip == False:
        print('\n--skip == False. Starting from a .hic file')
        print('Dump interaction matrices from a .hic file.....\n')
        DumpMatrix(args.outdir, args.prefix, args.juicertools, args.norm, args.hic, args.resolution1, args.resolution2, args.BP_FRAG, chromlist, args.threads)
        print('Make interaction matrix.pickle.....\n')
        if args.resolution1 == args.resolution2:
            IFdic1 = MakeIFpickleFiles(args.outdir, args.prefix, chrStartFragNumDic1, chrStartFragNumDic2, chromlist, args.resolution1, args.resolution2, args.BP_FRAG, args.threads)
        else:
            IFdic1, IFdic2 = MakeIFpickleFiles(args.outdir, args.prefix, chrStartFragNumDic1, chrStartFragNumDic2, chromlist, args.resolution1, args.resolution2, args.BP_FRAG, args.threads)
        print(f'Dump time : {time.time() - start_time}')
    else:
        print(f'\n--skip == True. Starting from pickle file(s)')
        print('\nLoading first pickle file.....')
        start_time = time.time()
        IFdic1 = LoadIFpickleFile(args.infile1)
        if args.resolution1 != args.resolution2:
            print('Loading second pickle file.....')
            IFdic2 = LoadIFpickleFile(args.infile2)
        print(f'loading time : {time.time() - start_time}')
    
    start_time = time.time()
    Gene_minMaxFragDic1 = GetminMaxFragOfGene(args.bedfile, resfile1, args.resolution1, args.outdir, args.prefix, args.BP_FRAG, chromlist)
    if args.resolution1 != args.resolution2:
        Gene_minMaxFragDic2 = GetminMaxFragOfGene(args.bedfile, resfile2, args.resolution2, args.outdir, args.prefix, args.BP_FRAG, chromlist)
        print(f'Analyzing multi gene domains.....')
        IdentifyMultiGeneDomain(args.outdir, args.prefix, chrEndFragNumDic2, Gene_minMaxFragDic2, IFdic2, chromlist, args.maxSize, args.maxDist, args.cutoff2, args.threads)
        print(f'Completed. time : {time.time() - start_time}')
    else:
        start_time = time.time()
        print(f'Analyzing multi gene domains.....')
        IdentifyMultiGeneDomain(args.outdir, args.prefix, chrEndFragNumDic1, Gene_minMaxFragDic1, IFdic1, chromlist, args.maxSize, args.maxDist, args.cutoff2, args.threads)
        print(f'Completed. time : {time.time() - start_time}')
    
    start_time = time.time()
    print('\nAnalyzing single gene domains.....')
    IdentifySingleGeneDomain(args.outdir, args.prefix, Gene_minMaxFragDic1, IFdic1, chromlist, 0.5, args.cutoff1, args.threads)
    print(f'Completed. time : {time.time() - start_time}')
    
    MakeAdditionalFiles(args.outdir, args.prefix, args.threads)
    tmpClearing(args.outdir, args.prefix, args.resolution1, args.resolution2, args.BP_FRAG)
    print(f'All analysis completed.\n')
