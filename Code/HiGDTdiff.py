#!/home/hongb/anaconda3/bin/python3
import subprocess as sp
import argparse
import os
import pandas as pd
import numpy as np
import pickle
import time
from scipy import stats

##usage
def parse_args():
    
    parser = argparse.ArgumentParser(description = "", formatter_class = argparse.RawTextHelpFormatter)
    parser.add_argument('-pk1', dest = 'pickle1', required=True, help = 
    '''Path to the matrix1.pickle file for the control sample.
By default, this file is generated by HiGDT.py and is located at {outdir}/{prefix}.{resolution}{BP/FRAG}.matrix.pickle.
    ''')
    parser.add_argument('-pk2', dest = 'pickle2', required=True, help = 
    '''Path to the matrix2.pickle file for the treat sample'
By default, this file is generated by HiGDT.py and is located at {outdir}/{prefix}.{resolution}{BP/FRAG}.matrix.pickle.
    ''')
    parser.add_argument('-gd1', dest = 'genedomain1', required=True, help = 
    '''Path to the HiGDT output file of the control sample including single-gene domains.
By default, this file is generated by HiGDT.py and is located at {outdir}/{prefix}.SingeGeneDomain.txt
    ''')
    parser.add_argument('-gd2', dest = 'genedomain2', required=True, help = 
    '''Path to the HiGDT output file of the treat sample including single-gene domains.
By default, this file is generated by HiGDT.py and is located at {outdir}/{prefix}.SingeGeneDomain.txt
    ''')      
    parser.add_argument('-b', dest = 'bedfile', required=True, help = 
    '''Path to the .bed file which includes genic information.
The 4th column should contain labels for each element.
    ''')
    parser.add_argument('-r', dest = 'refile', required=True, help = 
    '''Path to the fragment.bed file, which is composed of 'chromosome', 'fragment_start', 'fragment_end', 'fragment_number'.
The resolution of this file must match that of matrix.pickle files.
Both fixed intervals and restriction fragment intervals are allowed.
By default, this file is generated by HiGDT.py at {outdir}/{prefix}.{resolution}{BP/FRAG}.bed.
    ''') 
    parser.add_argument('-p', dest = 'prefix', required=True, help = 
    '''Prefix for naming output files.
    ''')
    parser.add_argument('-f', dest = 'flanking', default=2000, type=int, help = 
    '''The size of surrounding regions (bp) for the comparison.
The recommended range is 1000-3000 bp.
Default = 2000. 
    ''')
    parser.add_argument('-l', dest = 'lcut', default=1000, type=int, help = 
    '''The size cutoff (bp) of genes for the comparison. 
Should be larger than (resolution x 4).
Default = 1000.
    ''')
    parser.add_argument('-fc', dest = 'fc', default=0.2, type=float, help = 
    '''The fold chage cutoff for comparing surrounding contact frequencies. 
The fold chage of average contact frequencies (ACFs) within surrounding regions are calculated.
e.g. The value 0.2 means (Control ACFs) > (1-0.2) X (Treat ACFs). 
Default = 0.2 (0 < FC < 1). 
    ''')
    parser.add_argument('-c', dest = 'cutoff', default=0.05, type=float, help = 
    '''The P-value cutoff value for comparing surrounding contact frequencies.
Default = 0.05.
    ''')
    parser.add_argument('-o', dest = 'outdir', default = './', help = 
    '''Path to the output directory where all output files will be written.
Default = './'.
    ''')
    parser.add_argument('--norm', dest = 'norm', action='store_true', help = 
    '''Normalize o/e values by the sum of genome-wide surrounding contact frequencies.
Default = False.
    ''')
    return parser.parse_args()

def MaketmpDir(outdir):
    if os.path.isdir(f'{outdir}') == False:
        os.mkdir(f'{outdir}')
    if os.path.isdir(f'{outdir}/tmp') == False:
        os.mkdir(f'{outdir}/tmp')

def getminMaxDF(outdir, prefix, bed, refile, f):
    sp.run(f'bedtools intersect -a {bed} -b {refile} -wo | datamash groupby 1,2,3,4,5,6 min 10 max 10 > {outdir}/tmp/{prefix}.Frag_minMax.txt', shell=True)
    sp.run(f"less {bed} | awk '{{if ($2-{f}>0) print $1, $2-{f}, $3+{f}, $4, $5, $6 ; else print $1, 1, $3+{f}, $4, $5, $6}}' OFS='\t' | bedtools intersect -a - -b {refile} -wo | datamash groupby 1,2,3,4,5,6 min 10 max 10 > {outdir}/tmp/{prefix}.Frag_minMax.flanking.txt", shell=True)
    minMax_raw = pd.read_csv(f'{outdir}/tmp/{prefix}.Frag_minMax.txt', sep='\t', header=None, names=['chrom', 'start', 'end', 'geneid', 'b', 'strand', 'frag1', 'frag2'])
    minMax_flank = pd.read_csv(f'{outdir}/tmp/{prefix}.Frag_minMax.flanking.txt', sep='\t', header=None, names=['chrom', 'start', 'end', 'geneid', 'b', 'strand', 'frag1', 'frag2'])
    return minMax_raw, minMax_flank

def getNormFactor(minMaxdf, pickle1, pickle2, lcut, minMaxf):
    norm1 = 0 ; norm2 = 0
    for x in range(len(minMaxdf)):
        chrom, start, end, _, _, _, target_i, target_j = minMaxdf.iloc[x,:].values
        length = end - start
        if length >= lcut:
            f_start, f_end = minMaxf.iloc[x,6:]
            if (target_i - f_start) * (f_end - target_j) != 0:
                v1 = np.mean(SurrContact(target_i, target_j, pickle1[chrom], f_start, f_end))
                v2 = np.mean(SurrContact(target_i, target_j, pickle2[chrom], f_start, f_end))
                norm1 = norm1 + v1
                norm2 = norm2 + v2
    return norm2/norm1

def compareRegion(minMaxdf, pickle1, pickle2, lcut, minMaxf, sf, fc):
    tmplist = []
    for x in range(len(minMaxdf)):
        chrom, start, end, geneid, _, _, target_i, target_j = minMaxdf.iloc[x,:].values
        length = end - start + 1
        if length >= lcut:
            f_start, f_end = minMaxf.iloc[x,6:]
            if (target_i - f_start) * (f_end - target_j) != 0:
                v1, v2, p = getRegionDiff(target_i, target_j, pickle1[chrom], pickle2[chrom], f_start, f_end, sf)
                if p < 0.05:
                    if v1 <= v2*(1-fc):
                        sig = 'activated in control'
                    elif v2 <= v1*(1-fc):
                        sig = 'activated in treatment'
                    else:
                        sig = 'Not significant'    
                else:
                    sig = 'Not significant'
                tmplist.append(pd.DataFrame([{'geneid' : geneid, 'length' : length, 'region1' : v1, 'region2' : v2, 'pvalue' : p, 'Surrounding_contacts' : sig}]))
    outdf = pd.concat(tmplist, ignore_index=True)
    #outdf.to_csv(f'{outdir}/{prefix}.SurroundingCompare.tmp', sep='\t', index=False, header=False)
    return outdf

def getRegionDiff(target_i, target_j, pickle1, pickle2, f_start, f_end, sf):
    region1 = [i * sf for i in SurrContact(target_i, target_j, pickle1, f_start, f_end)]
    region2 = SurrContact(target_i, target_j, pickle2, f_start, f_end)
    p = stats.mannwhitneyu(region1, region2)[1]

    return np.mean(region1), np.mean(region2), p

def SurrContact(target_i, target_j, mat, f_start, f_end):
    v1list = []
    for i in range(f_start, target_i):
        for j in range(target_i, f_end + 1):
            try:
                v1list.append(mat[str(i) + '\t' + str(j)])
            except KeyError:
                v1list.append(0)
    for i in range(target_i, target_j + 1):
        for j in range(target_j + 1, f_end + 1):
            try:
                v1list.append(mat[str(i) + '\t' + str(j)])
            except KeyError:
                v1list.append(0)
    return v1list

def parseOutput(gd1, gd2, outdf, outdir, prefix):
    gd1set = set(sp.check_output(f'less {gd1} | cut -f 4', shell=True, universal_newlines=True).rstrip().split('\n'))
    gd2set = set(sp.check_output(f'less {gd2} | cut -f 4', shell=True, universal_newlines=True).rstrip().split('\n'))
    gd1_specific = gd1set - gd2set
    gd2_specific = gd2set - gd1set
    parsedf = outdf.query('((geneid in @gd2_specific) and (Surrounding_contacts == "activated in treatment")) or ((geneid in @gd1_specific) and (Surrounding_contacts == "activated in control"))')
    parsedf.to_csv(f'{outdir}/{prefix}.HiGDTdiff.out.txt', sep='\t', index=False, header=True)

if __name__ == '__main__':
    args = parse_args()

    MaketmpDir(args.outdir)
    start_time = time.time()
    with open(args.pickle1, 'rb') as pk1, open(args.pickle2, 'rb') as pk2:
        print(f'Load the first matrix......')
        mat1 = pickle.load(pk1)
        print(f'Load the second matrix......')
        mat2 = pickle.load(pk2)
    print(f'Load matrix time : {time.time() - start_time}')

    minMaxRaw, minMaxFlank = getminMaxDF(args.outdir, args.prefix, args.bedfile, args.refile, args.flanking)
    if args.norm == True:
        print(f'Calculate a normalization value...')
        sf = getNormFactor(minMaxRaw, mat1, mat2, args.lcut, minMaxFlank)
    else:
        sf = 1
    print(f'Normalization factor : {sf}')
    start_time = time.time()
    print(f'Compare regions......')
    outdf = compareRegion(minMaxRaw, mat1, mat2, args.lcut, minMaxFlank, sf, args.fc)
    parseOutput(args.genedomain1, args.genedomain2, outdf, args.outdir, args.prefix)
    print(f'Analysis completed : {time.time() - start_time}')
    sp.run(f'rm {args.outdir}/tmp/{args.prefix}.Frag_minMax.txt {args.outdir}/tmp/{args.prefix}.Frag_minMax.flanking.txt', shell=True)